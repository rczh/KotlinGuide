# Type-Safe Builders
通过使用命名良好的函数结合带有接收类型的函数文本，可以在Kotlin中创建类型安全的，静态类型的构建器

类型安全的构建器允许创建基于kotlin的领域特定语言DSL，DSL适合以半声明的方式构建复杂的分层数据结构

构建器的一些示例用例：

* 使用Kotlin代码生成标记，如HTML或XML

* 以编程方式布局UI组件: Anko

* 为web服务器配置路由: Ktor

## A type-safe builder example

```kotlin
fun result() =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // an element with attributes and text content
            a(href = "http://kotlinlang.org") {+"Kotlin"}

            // mixed content
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "http://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}

            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
```

这是完全合法的kotlin代码

## How it works
让我们看一下在kotlin中实现类型安全构建器的原理。首先我们需要定义要构建的模型，在本例中我们需要构建HTML标签。可以使用一些类来实现，比如HTML类用来描述&lt;html>标签，它定义了子标签&lt;head>和&lt;body>

现在看一下为什么我们能在代码中这样使用

```kotlin
html {
 // ...
}
```

html实际上是一个接收lambda表达式参数的函数，函数定义如下：

```kotlin
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```

函数接收一个名为init的参数，它本身也是一个函数，函数类型为HTML.() -> Unit，它是一个带有接收类型HTML的函数类型。也就是说我们可以在函数内部调用HTML实例的成员

可以通过this关键字访问接收类型对象

```kotlin
html {
    //head和body是HTML的成员函数
    this.head { ... }
    this.body { ... }
}
```

可以省略this关键字，现在它已经很像构建器了

```kotlin
html {
    head { ... }
    body { ... }
}
```

我们看一下上面定义的html函数。它创建一个新的HTML实例，然后通过调用作为参数传递的函数来初始化实例(在我们的例子中，为在HTML实例上调用head和body)，然后返回这个实例。这正是构建器需要做的

HTML类中head和body函数的定义与html类似。区别是它们将构建的实例添加到HTML实例的集合中

```kotlin
fun head(init: Head.() -> Unit) : Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -> Unit) : Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
```

由于这两个函数类似，我们可以实现一个通用的版本initTag

```kotlin
protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
```

现在这两个函数很简单

```kotlin
fun head(init: Head.() -> Unit) = initTag(Head(), init)

fun body(init: Body.() -> Unit) = initTag(Body(), init)
```

我们能使用它们去构建&lt;head>和&lt;body>标签

下面讨论如何向标签中添加文本

```kotlin
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
```

我们只是在标签中加入一个字符串，但在它前面有一个加号，它是前缀操作符unaryPlus的函数调用。该操作符是由扩展函数unaryPlus定义的，该扩展函数是TagWithText抽象类的成员

```kotlin
operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
```

前缀加号将字符串封装到TextElement中并将其添加到集合中，使它成为标签树的一部分

## Scope control: @DslMarker (since 1.1)
使用DSL时可能会遇到在上下文中可以调用太多函数的问题。我们可以在lambda表达式中调用每个可用的隐含接收类型的方法，从而得到不一致的结果。比如head标签在另一个head标签内部

```html
html {
    head {
        head {} // should be forbidden
    }
    // ...
}
```

在本例中，只有最近的隐含接收类型this@head的成员必须可用，head函数是外部接收类型this@html的成员，调用它是非法的

为了解决这个问题，在Kotlin1.1中引入了一种特殊的接收类型范围控制机制

要使编译器来控制作用域，我们需要用相同的注解注释DSL中使用的所有接收类型。例如，对于HTML构建器，我们声明一个注解@HTMLTagMarker

```kotlin
@DslMarker
annotation class HtmlTagMarker
```

如果注解类使用@DslMarker标注，则称它为DSL注解

在我们的DSL中，所有标签类都继承同一个父类。因此可以只使用@HtmlTagMarker注解父类，Kotlin编译器将把所有子类作为注解处理

```kotlin
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
```

我们不需要使用@HtmlTagMarker注解HTML或Head类，因为它们的父类已经被注解了

```kotlin
class HTML() : Tag("html") { ... }
class Head() : Tag("head") { ... }
```

在我们添加这个注解之后，Kotlin编译器知道哪些隐含接收类型是同一DSL的一部分，并且只允许调用最近接收类型的成员

```kotlin
html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}
```

注意，仍然可以调用外部接收类型的成员，但是必须显式的指定this接收类型

```kotlin
html {
    head {
        this@html.head { } // possible
    }
    // ...
}
```

## Full definition of the com.example.html package
下面是com.example.html包的完整定义，它构建了一个HTML树，它大量使用了扩展函数和带有接收类型的lambda表达式

注意，@DslMarker注解只在kotlin1.1之后可用

```kotlin
package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf<Element>()
    val attributes = hashMapOf<String, String>()

    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent<$name${renderAttributes()}>\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent</$name>\n")
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -> Unit) = initTag(Head(), init)

    fun body(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -> Unit) = initTag(B(), init)
    fun p(init: P.() -> Unit) = initTag(P(), init)
    fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```
